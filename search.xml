<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[冒泡算法及优化]]></title>
    <url>%2F2019%2F08%2F11%2F%E5%86%92%E6%B3%A1%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[在认识冒泡排序之前，我们先熟悉一下几个概念。 整体有序和局部有序​ 首先我们熟悉一下什么叫局部有序 和整体有序。在由一组整数组成的序列A[0，n - 1]中，满足A[i - 1] ≤ A[i]的相邻元素称作顺序的； 否则是逆序的。不难看出，有序序列中每一对相邻元素都是顺序的，亦即,对任意1 ≤ i &lt; n都 有A[i - 1] ≤ A[i]；反之，所有相邻元素均顺序的序列，也必然整体有序。 扫描交换​ 由有序序列的上述特征，我们可以通过不断改善局部的有序性实现整体的有序：从前向后依 次检查每一对相邻元素，一旦发现逆序即交换二者的位置。对于长度为n的序列，共需做n - 1 次比较和不超过n - 1次交换，这一过程称作一趟扫描交换。 ​ 以上图中由5个整数组成的序列A[0, 4] = { 6, 8, 5, 7, 4 }为例。 ​ 在扫描交换①过程中，{ 7, 4 }，{ 5, 4 }，{ 8, 4 }，{ 6, 4 }分别交换位置，扫描交换后的结果为{ 4, 6, 8, 5, 7}。 冒泡排序​ 可见，经过这样的一趟扫描，序列未必达到整体有序。如此，则要对该序列再做一趟扫描交换，比如，上图再经过扫描交换②的结果为{ 4, 5, 6, 8, 7 }。但是，每经过一次扫描交换，至少有一个元素移动到它应处的位置上。如经过扫描交换①，元素4移动到了正确位置上，多数的这类交换操作，都会使得越小（大）的元素朝上（下）方移动，直至它们抵达各自应处的位置。因此，经过反复多次扫描交换后，如图中结果所示，在序列中不再含有任何逆序的相邻元素。对于一个含有n的元素的序列，扫描交换次数最多为n-1。 ​ 排序过程中，所有元素朝各自最终位置的移动过程，犹如气泡在水中的上下沉浮， 冒泡排序(bubble sort)算法也因此得名。 算法实现根据上述冒泡排序的思路，我们可以准确描述和实现为如下所示的函数bubbleSortA( )。 123456789void bubbleSortA(int A[], int n)&#123; while(n &gt; 1)&#123; //逐趟进行扫描交换，共n-1趟 for(int i = 1; i &lt; n; i++)&#123; //自左向右逐对检查当前范围A[0, n)内的各相邻元素 if(A[i - 1] &gt; A[i]) //一旦A[i - 1]不A[i]逆序，则 swap(A[i - 1], A[i]); //交换 &#125; n--; //至此末元素必然就位，故可以缩短待排序序列的有效长度 &#125;&#125; 改进上述算法是基本的冒泡排序算法。但是我们会发现，如果一个序列刚开始一端是有序的，这个算法会做很多没有必要的比较，所以我们可以通过增加标志位来实现提前终止。即在某一遍扫描排序中并未发现逆序的情况，及时提前退出。 12345678910111213void bubbleSortB(int A[], int n)&#123; bool sorted = false; //整体排序标志，首先假定并未排序 while(!sorted)&#123; //逐趟进行扫描交换，共n-1趟 sorted = true; //假定已经排序 for(int i = 1; i &lt; n; i++)&#123; //自左向右逐对检查当前范围A[0, n)内的各相邻元素 if(A[i - 1] &gt; A[i])&#123; //一旦A[i - 1]不A[i]逆序，则 swap(A[i - 1], A[i]); //交换，并 sorted = false; //因整体排序不能保证，需要清除排序标志 &#125; &#125; n--; //至此末元素必然就位，故可以缩短待排序序列的有效长度 &#125;&#125; //借助布尔型标志位sorted，可及时提前退出，而不总是蛮力地做n - 1趟扫描交换 我们还可能遇到一个序列中间部分的元素是有序的，那么上面的改进方法还是会做很多没有必要的比较。所以我们可以通过记住最右（左）侧逆序对的位置来跳过无效冒泡。 12345678910111213void bubbleSortC(int A[], int n)&#123; int last = n; //记录最右侧逆序的位置 int temp = 0; //因last会更新，所以要记住上一次的last while(temp != last)&#123; //last不再变化，即没有逆序情况 temp = last; for(int i = 1; i &lt; temp; i++)&#123; if(A[i - 1] &gt; A[i])&#123; //若逆序 swap(A[i - 1], A[i]); //则交换，并 last = i; //更新最右侧逆序位置记录 &#125; &#125; &#125;&#125; 总结 不变性：经k趟扫描交换后，最大（小）的k个元素必然就位； 单调性：经k趟扫描交换后，问题规模缩减至n - k； 正确性：经至多n - 1趟扫描交换后，算法必然终止，而且能给出正确解答。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>冒泡算法</tag>
        <tag>优化</tag>
      </tags>
  </entry>
</search>
